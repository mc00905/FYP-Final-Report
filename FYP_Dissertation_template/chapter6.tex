\chapter{Testing and Evaluation}
\section{Introduction}

This section will detail my plans on how I will test my solutions, and how I will determine how they have measured up against the specifications defined for them.

There will be two main testing approaches throughout the project, individual Unit Testing on different components of the software, and more end-user oriented end-to-end testing where I will be actual using the functionality and deeming it functional. 
\section{Unit Testing with SuperTest, Jest and Nock}

My Unit Tests for both the micro-service and the client will use a number of key libraries, SuperTest, Jest and Nock. Whilst they will test the sample services I have created, the main aim will be to produce a suite of tools for general micro-service testing.
\subsection{SupertTest}
SuperTest is a Node.js library used for testing HTTP. By passing in the server export from the App.ts we can perform Unit Tests on the actual HTTP requests made through the server.

All aspects of the response can be tested including headers and status code, with the body of the response being the focal point of my testing. This will allow me to ensure that everything returned by the API is returned in both the format and shape that is expected, and the appropriate errors are thrown on respective requests.
\subsection{Jest}
Jest is a lightweight and very user-friendly JavaScript testing framework developed by Facebook. The tests themselves are split into separate processes and run in parallel, resulting in extremely fast and performant test suites.

Jest requires very little boilerplate configuration, and pretty much works out of the box making it very easy to get straight to writing Unit Tests on the code-base.

The framework also has the Istanbul code coverage tool built in. Istanbul tracks how much of our code is actually covered by our Unit Tests such as:
\begin{itemize}
    \item Functions: Are all the functions and methods tested
    \item Branching: Are all branches in the decision-making logic tested
    \item Statements: Are all variable assignments, return values etc tested
\end{itemize}

The reports generated by Istanbul detail what code isn't covered too, allowing the test suite to be expanded to cover these areas. The high the code coverage, the more of the code-base that is tested, which in turn should reduce the numbers of bugs introduced to the system.

It should be noted that Code Coverage and Test Coverage are different. Where Code Coverage tests how much of the code is tested in some way, Test Coverage measures those tests against actual Specifications and Requirements, testing the actual coverage of the expected functionality. As such where Code Coverage shines for Unit Tests, Test Coverage is a very good metric for Acceptance Testing.

For this project I will only be testing Code Coverage as the bulk of my physical tests will be Unit Tests.
\subsection{Nock}
Using the library for creating intercepting mock http requests - can show rate limiting handling works etc
\subsection{Unit Testing the Micro-service}
\subsubsection{Testing the Controllers}
supertest library - call controller endpoints - does response.toEqual expected type etc
\subsubsection{Testing the Data Agents \& Models}
dummy db - locolhost/test.. call agents, do the methods pass etc. Startup/Tear down db before/after tests. Can a posted object be retrieved, stuff deleted etc. 
\subsection{Unit Testing the Handcrafted Client}
\subsubsection{Intercepting HTTP Requests with Nock}
How do nock + jest tie together
testing each method - does it pull out the responses, handle Errror and rate limiting
\section{End-to-End Testing the Auto-generated Client}
\subsection{Calling the Micro-service Endpoints}
Actually press the buttons, use ts-node to call an index file with function calls. 
Does the generated code work - call endpoints correctly. Does typescript pick up the typings. Do the added features work
\section{Back to the Objectives}
\subsection{The Micro-service}
\subsection{The Handcrafted Client}
\subsection{The Auto-generated Client}
Have they been fulfilled etc
Why, why not