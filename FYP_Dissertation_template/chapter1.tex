\chapter{Introduction}
\section{Project Motivation and Background}

Micro-services are a relative style of software architecture which has been gaining increasing popularity over the last few years. Rather than having a single monolithic application, a micro-service architecture breaks the application down into loosely coupled services which communicate with one-another. Over the last couple of years at Hindsight, we have been migrating from our legacy Java monolithic application, to a collection of lighter weight Node.js TypeScript micro-services.

Micro-services solve a lot of the issues which the monolithic architecture have. Code-base changes are isolated to the micro-service responsible for the feature being modified, so changes in one part of the system will have no impact on other parts. The same goes for bugs, which are likely to be isolated to single services at a time. However, micro-services do introduce issues that monoliths do not face.

In order for the application to work, the micro-services must establish communications with each other. Data will be passed and processed between micro-services, with each micro-service carrying out it's own niche functionality. These communications are typically handled through the use of APIs. An API defines the interface through which communication with the service can occur, specifying the shape of both requests and responses as well as any data formats that should be used.

Each micro-service details not only it's own unique API, but must also have knowledge of how to consume the APIs of all the other services that it needs to communicate with. In the case of Hindsight, we have over two dozen micro-services, and often a service will interact with at least four or five additional services. Ensuring that communication is happening as expected between all these services is paramount if the application is going to operate reliably. Outside of our own micro-services, we also communicate with  external APIs for services such as GitHub, Bitbucket, Gitlab and Jira.

Over the course of our architecture shift, we have encountered a number of problems working with our micro-services, mainly in handling the communication between the individual services. Each service needs to have code acting as an API client for each and every other service that it needs to communicate with and so, code can be quite heavily duplicated across the entire architecture. Additionally, we have encountered issues handling error responses between the services, as well as transferring knowledge of API request responses from the server to client micro-service. The aim of this project is to alleviate these issues through code-generation of API clients, with these new clients solving the problems we have been facing and being able to be installed as dependencies of each micro-service to reduce duplication and code overhead.

\section{Aims and Objectives}
 \begin{enumerate}
   \item Explore and evaluate the different types of APIs
   \item Explore and evaluate different specification formats for REST APIs
   \item Explore and evaluate expected functionalities of a modern REST API
   \item Explore and compose a list of best practises for consuming REST APIs
   \item Evaluate and choose a suite of TypeScript and Node.js tools and libraries for creating a well-documented RESTful API
   \item Evaluate and choose a suite of TypeScript and Node.js tools and libraries for creating a RESTful API client
   \item Create a Node.js micro-service with a well-documented and standardised REST API
   \item Create functionality for exporting the API specification from the micro-service
   \item Create an API client library consuming the micro-service and handling expected error cases
   \item Explore and evaluate technologies for automatically generating API client libraries
   \item Create or modify a code generator in order to generate API clients from an API specification
 \end{enumerate} 
 \section{Summary}
 
 This project aims to help alleviate the issues faced by both the client and the server services. Over its course, I will create an example Node.js micro-service with its own REST API. I will then create a handcrafted client library consuming the API, before exploring ways to automatically generate client libraries for APIs. Finding a way to automatically generate a client library from an API specification will completely remove all of the issues related to maintaining code consuming the services. If information related to the request and response payloads can be provided as TypeScript types, then the consumers will have all of the information that they need in order to effectively interact with the micro-service.