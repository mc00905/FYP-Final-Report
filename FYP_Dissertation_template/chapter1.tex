\chapter{Introduction}
\section{Project Motivation and Background}

Micro-services are a relatively style of software architecture and have been gaining increasing popularity over the last few years. Rather than having a single monolithic application, a micro-service architecture breaks the application into loosely coupled services that communicate with one-another. Over the last couple of years at Hindsight, we have been migrating from our legacy Java monolithic application, to a collection of lighter weight Node.js TypeScript micro-services.

Micro-services solve a lot of the issues that the monolithic architecture have. Code-base changes are isolated to the micro-service responsible for the feature being modified, so changes in one part of the system will have no impact on other parts. The same goes for bugs, which are likely to be isolated to single services at a time. However, micro-services do introduce issues that monoliths do not face.

In order for the application to work, the micro-services must establish communications with each other. Data will be passed and processed between micro-services, each micro-service carrying out it's own niche functionality. These communications are typically handled through the use of APIs. An API defines the interface through which communication with the service can occur, specifying the shape of both requests and responses as well as any data formats that should be used.

Each micro-service will have it's own unique API, but must also have knowledge of how to consume the APIs of all the other services that it needs to communicate with. In the case of Hindsight, we have over two dozen micro-services, and often a service will interact with at least four or five additional services, and so ensuring that communication is happening as expected is paramount. Outside of our own micro-services, we also communicate with the external APIs for GitHub, Bitbucket, Gitlab and Jira.

At Hindsight our APIs follow the RESTful architecture, utilising HTTP requests to communicate.

During our transition to micro-services we have encountered the following issues:
\begin{itemize}
  \item Lack of documentation for APIs: Documenting APIs is crucial, consumers need to know how to make requests, and what responses look like. Ensuring the documentation is up to date and accurate is mandatory in order for an API to be used effectively.
  \item Duplication of code handling communication between micro-services: Every micro-services will have code responsible for communicating with all of the other micro-services it needs to send requests to. If the API is modified or new endpoints are added, each service consuming the API is going to need to also have the modifications applied.
  \item The client service lacks knowledge about the shape of the response when a request is made: In a monolithic architecture, all the code is encapsulated under the same umbrella, and so if one part of the system communicates with another part, all of the class information will be provided. This is even more of an issue with external APIs. If we make a request to GitHub, the service making the request needs to know the format and structure of the response so that we can consume the information provided as we need to. Currently we have to manually create TypeScript types detailing request and response bodies. The issue with this approach is that it is very static, any changes will need to be copied across all of the services consuming the API, and the whole process is extremely time consuming.
  \item Handling HTTP errors: Errors happen, and sometimes a request to a service will fail. The server might have hit an exception it couldn't recover from, or an underlying issue with the hosting may have temporarily knocked service out. Alongside this RESTful APIs often make use of techniques such as Rate Limiting in order to protect their services from DoS attacks. The API will allow X number of requests over a time-frame of Y. If the number of requests exceeds this number, then errors will be thrown on subsequent requests until the allotted time-frame is exceeded. 
  These errors usually return specific HTTP status codes in the response, informing the client what went wrong with the request. Having mechanisms in place for automatically handling these errors, and trying to send the request again after an indeterminate amount of time will help to prevent avoidable errors from bubbling up the micro-service chain.
\end{itemize}

\section{Aims and Objectives}
 \begin{enumerate}
   \item Explore and evaluate the different types of APIs
   \item Explore and evaluate different specification formats for REST APIs
   \item Explore and evaluate expected functionalities of a modern REST API
   \item Explore and compose a list of best practises and requirements for consuming REST APIs
   \item Evaluate and choose a suite of TypeScript and Node.js tools and libraries for creating a well-documented RESTful API
   \item Evaluate and choose a suite of TypeScript and Node.js tools and libraries for creating a RESTful API client
   \item Create a Node.js micro-service with a well-documented and standardised REST API
   \item Create functionality for exporting the API specification from the micro-service
   \item Create an API client library consuming the micro-service and handling expected error cases
   \item Explore and evaluate technologies for automatically generating API client libraries
   \item Create or modify a code generator in order to generate API clients from an API specification
 \end{enumerate}
 
 \section{Summary}
 
 This project aims to help alleviate the issues faced by both the client and the server services. Over its course I will create an example Node.js micro-service with its own REST API. I will then create a handcrafted client library consuming the API, before exploring ways to automatically generate client libraries for APIs. Finding a way to automatically generate a client library from an API specification will completely remove all of the issues related to maintaining code consuming the services, and if information related to the request and response payloads can be provided as TypeScript types, then the consumers will have all of the information that they need in order to effectively interact with the micro-service.