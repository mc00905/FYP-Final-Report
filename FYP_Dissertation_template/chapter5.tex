\chapter{System Design}
\section{Introduction}

In this section of the report I will explain and justify the design decisions I have made relating to both the architecture of my systems, and the libraries they employ.

The project is going to consist of three differing systems. The first will be an exemplar Node.js TypeScript RESTful micro-service, developed to showcase techniques to develop the services in general.  It will be a pretty basic service, fulfilling the basic functionality expected of a modern micro-service. The second will be a TypeScript NPM module, acting as a client library that consumes the API of the micro-service and allows the Node.js service that imports the module to access the API. The final part of the project is a number of modifications made to the OpenAPI Generator typescript-axios templates. These changes will add any missing functionality to the generated client, using my NPM module as a baseline.

\subsection{Client-Server API Interactions}

The foundation of the project is in the interactions between micro-services. Each individual micro-service will utilise a RESTful API to expose its functionality to other services within the application through the use of HTTP requests. This follows the typical Client-Server model, where the service making the request acts as the client, and the owner of the API being requested acts as the server. Any number of micro-services can make requests to any of the APIs within the overarching application and so the system design needs to facilitate this in a scalable way.

TODO: INSERT API - API CLIENT DIAGRAM HERE

The end goal of the project is to provide the ability for all micro-services in a distributed application to produce an API client for their APIs that the other services can use without any client related code needing to be written. This will allow more development time to be put into the actual application logic of the system, reduce duplicated code across multiple services and provide a communication platform that is robust and reliable. 

\section{Premise of the micro-service}
The aim of the project is to provide a framework of tools for creating services in general and not any particular service. The micro-service created as part of the project will be a simple example showcasing the interactions between the tools and how they are used, the actual business logic of the system having no real bearing on the project itself. The service will simulate a simple Stock Control component that could be used by any sort of supermarket or shopping application. This should allow me to demonstrate all I need to without getting bogged down in business logic complexities. It will be connected to a simple back-end database, and allow different products to be added, updated and deleted from the system. 

\section{RESTful API Design}
The first part of the system to be designed is the REST API for the exemplar micro-service. One of the key features of a micro-service architecture is that it allows the different services to be written in different frameworks and languages, and so the API must be language-agnostic. As such all request and response bodies will use JSON. This means that although the micro-service, based on the technology stack at Hindsight, will be a Node.js service written in TypeScript, theoretically any programming language that can handle JSON payloads will be supported.

In line with REST API best practises, all endpoint resources will be named with nouns, and the plural form will be used. The noun used for the base API will be shoppingItems. A shoppingItem representing one item within the API and shoppingItems representing the collection as a whole. 
As such, the base endpoint will be:
\begin{verbatim}
    /REST/1.0/shoppingItems
\end{verbatim}

Support will need to be provided for all CRUD operations for an API, supporting the HTTP verbs GET, POST, PUT and DELETE. Both a singular shoppingItem and the contents of the collection need to be fetched, and a subset of the properties of individual shoppingItems will need to be updated. New shoppingItems will need support for creation, and existing shoppingItems need to be able to be deleted.

\subsection{The API}
Descriptions of the planned API endpoints can be found below:

\emph{All request and response bodies will be formatted as JSON.}

\subsubsection{The shoppingItem Response Object}
\emph{Each shoppingItem will have the following properties:}
\begin{verbatim}
    name: A string representing the unique name of the shoppingItem.
    category: An enumerated type representing the type of shoppingItem.
    numberOfStock: A representation of the number of the shoppingItem in stock
    inStock: A boolean representing the state of numberOfStock > 0
\end{verbatim}
\subsubsection{API Endpoints}
\begin{verbatim}
GET /REST/1.0/shoppingItems
    Description:
        Retrieve all shoppingItems
    Query Parameters:
        page: page number of results returned by the query
        pageSize: the number of results per page
        inStock: filter items matching the inStock state provided
        category: filter items matching the category provided
    Additional note:
        Endpoint will be paginated, pages accessed using the page query 
        parameter + the page and totalPages fields within the response body
    Success Status Code: 200
    Response: 
        {
            shoppingItems: shoppingItem[]
            pageSize.
            page: current page number
            totalPages: number of total pages
        }
\end{verbatim}\medskip

\begin{verbatim}
POST /REST/1.0/shoppingItems
    Description:
        Create a new shoppingItem
    Request Body:
        {
            name: Name of the new shoppingItem,
            category: Category of the new shoppingItem,
            numberOfStock: Number of stock for the new shoppingItem,
        }
    Success Status Code: 201
    Response: No Response returned
\end{verbatim}\medskip

\begin{verbatim}
GET /REST/1.0/shoppingItems/{name}
    Description:
        Get an individual shoppingItem by name
    Path parameters:
        name: The name of the item being queried
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip

\begin{verbatim}
DELETE /REST/1.0/shoppingItems/{name}
    Description:
        Delete an individual shoppingItem by name
    Path parameters:
        name: The name of the item being queried
    Success Status Code: 204
    Response: No Response returned
\end{verbatim}\medskip

\begin{verbatim}
PUT /REST/1.0/shoppingItems/{name}/increaseStock
    Description:
        Increase the named shoppingItem stock by value provided in body
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            value: number to increment by
        }
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip

\begin{verbatim}
PUT /REST/1.0/shoppingItems/{name}/decreaseStock
    Description:
        Decrease the named shoppingItem stock by value provided in body
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            value: number to decrement by
        }
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip


\begin{verbatim}
PUT /REST/1.0/shoppingItems/{name}/category
    Description:
        Update the named shoppingItem category
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            category: new category value
        }
    Success Status Code: 200
    Response:
        shoppingItem
        
\end{verbatim}\medskip

\section{Technologies and Libraries}

The next stage of the design process is going to be determining any libraries and frameworks that I am going to use in the software. There is no point in redesigning the wheel, and well established libraries provide robust and well-tested solutions to common problems.

\subsection{Node.js}
The micro-service will be implemented using the Node.js run-time environment. This allows me to model the micro-service after the micro-services used at Hindsight and has the added benefit of providing me with familiarity, meaning I don't have to learn anything new. Node.js is used industry wide for back-end APIs due to its asynchronous and non-blocking event handling and is also relatively lightweight whilst maintaining good performance. Through the use of NPM, a package manager for Node.js, hundred of thousands of public libraries and modules can be imported and utilised, providing access to well-tested and reliable code. This allows Node.js developers to avoid writing common code, as well as providing them to modularise their code into both public and private packages that can be shared across code bases. During the development of both the micro-service and the client I will be importing a number of public NPM packages into my code.

\subsection{TypeScript}
Node.js services are traditionally written in vanilla JavaScript, but through the use of NPM support can also be added for TypeScript.

TypeScript at its core is just a superset of JavaScript, aiming to alleviate some of the foundational issues with language by adding features such strong type and generics support to JavaScript. Upon compilation, TypeScript is compiled back into vanilla JavaScript and so can typically be used anywhere JavaScript is used.

Having used both JavaScript and TypeScript during development of micro-services, I could never go back to JavaScript. Personally I find the support added by TypeScript allows me to develop software far, far faster. The addition of types allows methods to define exactly what they return, and when tied in with a good IDE, the code prediction facilities provided by TypeScript allow a far more agile way of working. TypeScript code is also naturally documented by its types, parameters types are explicitly specified allowing some issues to show up as errors in the IDE before any code is even run through type checking.

Because TypeScript is a superset of JavaScript, if for some reason some component does need to be written in raw JavaScript, that is also accepted by the compiler.
\subsection{OpenAPI Specification}
The OpenAPI specification is a language-agnostic RESTful API specification that is widely used across the industry. In my opinion it is the most user-friendly specification out there and provides a huge ecosystem of different tools and integrations. It will be the API specification I will be using for this project. 

The specification document can be written in JSON or YAML, and provides details about all aspects of the REST API. When tied into language-specific tools the API specification can be used to generate both API clients and servers.
\subsection{Micro-service specific libraries}

In this section I will describe and justify the libraries and frameworks I have decided to use in development of the exemplar micro-service.

\subsubsection{Express.js}
Express.js is a framework I will be using as the base of my micro-service. The Node.js ecosystem contains a number of widely used frameworks, but Express.js is arguably the most popular. It is lightweight and extensible, and handles a lot of the more tedious aspects of setting up a Node.js application. Express allows middleware to be easily plugged in, allowing a developer to easily import and use libraries for handling a huge volume of different use cases. Common middleware includes cookie and session support as well as things like custom error handling.

The Express framework is also the framework that most of the micro-services at Hindsight use, and so I am also very familiar with it.
\subsubsection{TSOA}
TSOA is an NPM library that that aims to treat the controller and data models of an application as the single source of an truth for the API. It defines routes for the endpoints and validates request payloads based on information provided the controllers and data models.The beauty of this approach is that as changes are made to either of these two parts of the system, the API is automatically updated to support the changes. TSOA allows tightly-woven typings across the application, all the way from the database layers up to the responses returned by the controllers.

The library uses a number of decorators in conjunction with TypeScript in order to define how the generated API will function. The developer decorates the methods in the controllers with information about the endpoint URL, HTTP verbs to support and default response code that the endpoint will return. Parameters within the controller methods are then decorated to define URL path parameters, query parameters as well as the request body payload. TSOA automatically picks up the response for the endpoint from the return type of the method. 

It generates routes for a number of different frameworks, including Express, and automatically validates incoming data against the API definitions. If the format of the data sent is not as expected, or the fields do not match, then it will reject the request and throw an error.

TSOA can also generate an OpenAPI Specification for the API.Through usage of the JSDoc markup language, tonnes of additional information can be added to allow the generated specification to act more like living documentation for the API. Example requests and responses payloads can be included, as well as endpoint and parameter descriptions.

The library does a lot of the heavy lifting for a micro-service, especially the tasks concerning routing and data validation, alongside handling the OpenAPI Specification requirement and so TSOA will be an integral part of the technology stack I use.
\subsubsection{Swagger-UI-Express}
Swaggger-UI-Express is another NPM package that generates Swagger-UI based API Documentation. It essentially takes an OpenAPI Specification in JSON format, and generate a HTML page representing the specification in an easily-readable format.

It also allows requests to be made to the API directly from the web page, allowing the API to be utilised without any client related code. This allows easy testing of the API during development without having to manually type out convoluted CURL commands in order to make requests.

When injected as middleware, the package can be used to create a documentation endpoint that automatically serves the Swagger-UI HTML page. By tying in both this package, and TSOAs specification generation, we can automatically publish API documentation. This means that as soon as code changes are published, a new API specification will be generated  and documentation for the modified API will follow instantly.
\subsubsection{Express-Rate-Limit}
This NPM package is a very simple rate limiting middleware. It is lightweight, but comes with the caveat that it recognises are requests as coming from  the same entity, and so all users will share the same rate limit timer. As this project is focussed on the interactions between an API client and server, this limitation is a non-issue, and this library provides the rate limiting proof of concept needed for the clients functionality to be testing against.
\subsubsection{Mongoose}
In order to properly support the CRUD requirements of the API, a simple and lightweight MongoDB database will be integrated into the micro-service.

Mongoose is an NPM module that handles the vast majority of the logic involved in creating and interacting with a MongoDB database, cutting down on a huge volume of otherwise boilerplate code. It is schema-based, and so can also validate requests made to and from the database. It also provides support for injecting TypeScript types into its model definitions, allowing strongly typed response definitions to be returned from database queries. This allows the same type definitions to be used across all layers of the micro-service, and when used with TSOA decorators can provide API definitions using these typings. This means if the underlying database format and specifications are changed, then the API definition itself will be changed too.
\subsubsection{Mongoose-Pagination-V2}
The Mongoose-Pagination-V2 NPM package is a library that provides access to a Mongoose plugin. The plugin facilitates the use of a wrapper method on database queries that splits up the result of the query into paginated chunks.

Pagination can be fairly easily obtained using vanilla Mongoose via the Skip and Limit operators. Skip simply tells the query to Skip x number of documents, whereas Limit gives an upper bound on the number of documents returned. Pagination can be simulated by setting the value of Skip to the Page Number of the request multiplied by the value of Limit. This will set the starting position of the query to the "Page Number" requested. However this approach does not easily expose the number of available pages to the consumer of the request and so makes iterating through the pagination less friendly. It is also not scalable for huge collections, and the use of Skip and Limit can become CPU and I/O bound for large sets of documents.

The Mongoose-Pagination-V2 library instead is cursor-based and so does not have the same scalability concerns. It also provides all of the extra meta-data related to pagination and makes exposing exactly what data is being displayed to the user painless.

\subsection{Client specific libraries}
In this section I will look at  the tools and libraries I will within the API Client, as well as how I plan on publishing the client as a module. 
\subsubsection{Creating the Client as an NPM Library}
Seeing as the project is based on Node.js micro-services, configuring the Client library as an NPM library makes the most sense. The Client can easily be packaged and published to the NPM registry, either publicly or privately, and the micro-services can then readily install and utilise it. This also allows me to import other NPM packages as dependencies for my client, saving on the amount of otherwise unnecessary home-brewed code. Physically publishing the package is out of scope of this project, but the fundamental setup for the process will be done.
\subsubsection{Axios}
The key functionality of an API client is making requests to an API, and so choosing the right library for making HTTP requests is key.

The library Request is a very popular and easy to use solution for making HTTP requests, and is what a lot of the Hindsight micro-services use to communicate between services. The library was however deprecated in early 2020, and so following developer best practises, an alternative should be used.

Axios is a widely used alternative to Request. It provides a lot of powerful functionality like the ability to cancel requests, and automatically parses JSON data and encodes URL parameters. Requests can be heavily configured, providing options for things like transformation of request data into different formats, serialisation of parameters and the use of proxy servers.

Axios is also promise based. Node.js is asynchronous, and promises are a mechanism for dealing with asynchronicity without having to resort to a large number of callbacks. This usage of promises allows Axios to provide the ability to intercept both requests and responses before they are passed back to the calling function. A key use case for this in my project will be facilitating automatic retries on certain failed requests. 
\subsubsection{Axios-Retry}
Axios-Retry is a simple NPM library that provides access to an Axios interceptor that allows failed requests to be caught and sent again. The interceptor can be configured to retry the request any amount of times, and can take in arguments for delays between retries as well as conditions for which status codes get retried. Although fundamentally a very small library, it saves me from writing code unnecessarily. 

\subsection{OpenAPI Code Generator}
The OpenAPI Generator provides a huge number of template configurations supporting different programming languages and frameworks. In this section I will explain why I chose the typescript-axios option.
\subsubsection{The typescript-axios templates}
The base of my handmade REST Client is the Axios HTTP library, and so utilising the typescript-axios configuration for the OpenAPI Generator should make pulling changes across the software fairly simple.

The generated client is also setup as an NPM package, and so fulfils my concerns around easily importing and using the client in Node.js services. As a baseline, the generated code only has TypeScript and Axios as dependencies and therefore has no deprecated libraries in use. This should make it a fairly stable option longterm as Axios and TypeScript are both likely to stick around.

\section{Microservice}
The micro-service is a Express based Node.js service broken down into a three layer architecture: the \emph{data-layer}, \emph{middleware} and \emph{service-layer}.

It is worth noting again that the complexities of the actual behaviour of the service are unimportant, and all of the design decisions made for this example can be used across any real micro-service. The focus is on the general architectural decisions and choice of libraries and tooling.
\subsection{data-layer}
This layer will handle all of the business logic of the service, namely interacting with the database in order to fetch the information sent and requested through the API.
\subsubsection{models/ShoppingItemModel.ts}
The models directory will be where the Mongoose models and schemas for the service are defined. The schemas define the fields required for the documents within a collection, allowing validation by Mongoose automatically when the create and update wrappers are called. The model acts as interface for interacting with the schema, wrapping the CRUD operations boilerplate and packaging it into a simple object.  
\begin{verbatim}
    This file will define the Mongoose schema for the ShoppingItem 
    collection. It will define the shape of the data, and create the
    actual collection in MongoDB. It will then create a Mongoose 
    model that exposes all of the CRUD operations related to the 
    collection. This will allow the data-agents to  interact with
    the database without writing unnecessary boilerplate code. The
    Mongoose-Paginate-V2 plugin will also be wired into the schema 
    providing isolated access to the paginate functionality within
    only this collection. If any further collections are to be added,
    the pagination function will not be needed as default and so the
    dependency is unnecessary.
\end{verbatim}
\subsubsection{data-agents/ShoppingItemAgent.ts}
The data-agents acts as a middleman between the controllers and the models. They take the data passed in from the controllers, do any processing or formatting required for the actual database queries. They then pass in the formatted data into the wrapper methods from the model with any configuration options relevant to the request. They then do any post-processing on the results that the controller might need before bubbling the result back up. The data-agents also handle and wrap any errors that might be thrown by the models and transform them into more helpful HTTP errors.
\begin{verbatim}
    The ShoppingItemAgent will be the data-agent responsible for 
    calling and handling the ShoppingItemModel. It will contain 
    a method related to each of the REST API endpoints, and 
    using the data passed into it from the ShoppingItemController
    will interact with the ShoppingItem collection. It will handle
    any logic involved in both the pre and post-processing of data
    and will map an errors thrown into one of the errors from the 
    ErrorLibrary.
    
    createShoppingItem()
        Method related to the creation of a ShoppingItem within the
        database. Will call the findOneAndUpdate() model method. The use
        of the ShoppingItem name as the unique identifier for the
        collection means that namespace collisions need to be avoided
        and so using the findOneAndUpdate function with the upsert flag
        set will overwrite the previous document with the name if the same
        name is used again.
    
    getShoppingItem()
        Fetch an individual ShoppingItem from the collection based on a
        name field passed in. Simple usage of the findOne() model method
        using a query built around the name field. If no results are 
        returned then a custom ShoppingItemNotFoundError is thrown with 
        an assigned HTTP status code of 404.
    
    getShoppingItems()
        Method for requesting multiple ShoppingItems, either the entire
        collection, or a subset based on parameters for ShoppingItemCategory
        or the inStock boolean.
        Results will be paginated, and information related to current page
        and total number of pages will be returned in the response.
        Different pages can be accessed through usage of the Page parameter 
        and the number of results per page can be changed through the 
        PageSize parameter. If no results are found an empty array will be
        returned. 
    
    updateShoppingItemCategory()
        Simply update the ShoppingItemCategory of the document with the
        queried name. Uses the findOneAndUpdate() model method and the
        new, updated version of the document will be returned. If no results 
        are  found for the name passed in then a custom 
        ShoppingItemNotFoundError is thrown with an assigned HTTP status 
        code of 404.
    
    
    increaseShoppingItemStock()
        Increment the NumberOfStock field of the document with the name
        passed in by the number in the value field. If the stock level is
        raised from 0 then the boolean InStock will be flipped. Again the
        method uses findOneAndUpdate() and returns the updated document.
        If no ShoppingItem is found  with the queried name then a custom  
        ShoppingItemNotFoundErroris thrown with an assigned HTTP status 
        code of 404.
        
    decreaseShoppingItemStock()
        Decrement the NumberOfStock of the targeted document. Validation
        catches negatives number and sets the NumberOfStock to 0 in these
        cases. Model method used is findOneAndUpdate() with the modified 
        form of the document being returned. If no ShoppingItem is found 
        with the queried name then a custom  ShoppingItemNotFoundError 
        is thrown with an assigned HTTP status code of 404.
    
    deleteShoppingItem()
        Delete the targeted ShoppingItem using the name field. Uses the
        model function findOneAndRemove() to handle the deletion. If no 
        ShoppingItem is found with the name passed in then a custom 
        ShoppingItemNotFoundError is thrown with an assigned HTTP 
        status code of 404.
        
\end{verbatim}
\subsection{middleware}
This will be where the logic used across the micro-service will be abstracted and stored, mainly TypeScript types and error definitions. This will also be where the literal middleware is configured such as the rate limiting configuration and error handler.
\subsubsection{enums/ShoppingItemCategories.ts}
Simple enumeration types library for the micro-service. Helpful for ensuring only certain field values can get through the TSOA validation and across the controllers and data-agents.
\begin{verbatim}
    A simple enumeration type detailing the valid ShoppingItem categories.
\end{verbatim}
\subsubsection{types/ErrorLibrary.ts}
\begin{verbatim}
    The ErrorLibrary takes the generic ErrorWrappers and contextualises them
    by assigning a value to the unique ErrorIdentifier field. 
    This allows the error to be easily identified at a glance. We can simply 
    look at where the specific error in the library is thrown and 
    investigate the cause from there. Not so important in this small 
    service, but in a  large distributed system, identifying the root cause
    of errors  is extremely important and so this added context is a 
    necessity as errors  will be potentially bubbling up across multiple 
    services.
\end{verbatim}
\subsubsection{ShoppingItem.ts}

\begin{verbatim}
    Simple TypeScript interface for defining the ShoppingItem type for
    use across the service. Additionally usage of JSDoc annotation around
    the fields allows TSOA to add descriptions of each property to the
    OpenAPI Specification on generation.
\end{verbatim}
\subsubsection{ErrorHandler.ts}
\begin{verbatim}
    Custom error handling middleware. Has explicit handling of the
    ErrorWrapper errors thrown by the data-agents as well as handling
    the validation thrown by TSOA. This ensures the additional meta
    properties of the error are returned to the user and that the 
    status codes are set as expected.If the error is neither of 
    these formats it gets piped onto a handler for generic errors
    which uses a default error message and status code if they are
    missing.
    All of the error bodies are returned as JSON to maintain the
    language-agnostic nature of the API.
\end{verbatim}
\subsubsection{ErrorWrapper.ts}
\begin{verbatim}
    Custom extensions of the default Node.js Error object. Adds
    custom fields for additional details, status code and a unique
    error identifier. This generic ErrorWrapper is further extended
    by implementations for each expected HTTP status code, where the
    extended class simply defines the status code for its parent
    ErrorWrapper object.
\end{verbatim}
\subsubsection{RateLimiter.ts}

\begin{verbatim}
    Super simple implementation of the Express-Rate-Limit package,
    essentially assigning configuration values.
\end{verbatim}
\subsection{service-layer}
The \emph{service-layer} will handle all of the logic associated with serving and processing the HTTP requests. This will be where all the controllers are defined and where the TSOA generated route files are created.
\subsubsection{controllers/ShoppingItemController.ts}
\begin{verbatim}
    The ShoppingItemController is where all of the TSOA related
    definitions and decorating is configured.
    
    The base ShoppingItemController class is decorated using
    the Route() decorator. This defines the base URL that
    all of the method specific URLs will append. In this case
    it is set to "/REST/1.0/shoppingItems".
    
    JSDoc notation will be used across the controller class,
    primarily before method definitions to provide TSOA with
    information about method descriptions and examples for fields and
    parameters.
    Additional decorators are injected in to help document any
    expected errors that the API will throw. This is done through
    the use of the @Res decorator and will add the error information
    to the OpenAPI Specification.
    
    Other Decorators used:
        @Get() @Post() @Put() @Delete(): 
            Map URL and HTTP Verb to the
            function. 
            Under the hood URL is set to {baseUrl}/{URL}
                Get(/{name}) => GET /REST/1.0/shoppingItems/{name}
        @Path(): 
            Define a path parameter, maps the field within the
            URL to a variable.
        @Query(): 
            Define a query parameter,maps the field within the
            URL to a variable.
        @Body(): 
            Define the request body, maps the request body to a 
            variable.
        @Response(): 
            Define errors, subtly different from @Res
            and only works with more static errors like the TSOA
            ValidationError.
        @Example(): 
            Define an example response for the generated
            OpenAPI Specification.
        
    
    See the API documentation for detailed information on the API.
    
    createShoppingItem()
        Mapped to:
            POST /REST/1.0/shoppingItems
        Passes in the request body information to the createShoppingItem()
        function in the ShoppingItemAgent and decorates the response
        status code as 201 to represent the resource successfully being
        created.
    
    getShoppingItems()
        Mapped to:
            GET /REST/1.0/shoppingItems
        Calls getShoppingItems() method from the agent and passes in the
        optional query parameters for filtering and pagination if they are
        present. Simply returns the response from the agent alongside a
        200 status code.
    
    getShoppingItem()
        Mapped to:
            GET /REST/1.0/shoppingItems/{name}
        Passes in the path parameter name to the getShoppingItem() agent
        method. Returns the response from the function with a HTTP status
        code 200.
    
    updateShoppingItemCategory()
        Mapped to:
            PUT /REST/1.0/shoppingItems/{name}/category
        Call the updateShoppingItemCategory() agent function with both
        the name path parameter and the request body fields. As we are
        returning the updated document set the status code to 200.
        
    increaseShoppingItemStock()
        Mapped to:
            PUT /REST/1.0/shoppingItems/{name}/increaseStock
        Call the increaseShoppingItemStock() agent function with both
        the name path parameter and the request body fields. As we are
        returning the updated document set the status code to 200.
        
    decreaseShoppingItemStock()
        Mapped to:
            PUT /REST/1.0/shoppingItems/{name}/decreaseStock
        Call the decreaseShoppingItemStock() agent function with both
        the name path parameter and the request body fields. As we are
        returning the updated document set the status code to 200.
        
    deleteShoppingItem()
        Mapped to:
            DELETE /REST/1.0/shoppingItems/{name}
        Pass in the name path parameter to the deleteShoppingItem()
        agent method. Decorate the response status code as a 204 to
        inform the API consumer the resource was deleted. 
\end{verbatim}
\subsubsection{routes/Routes.ts}
\begin{verbatim}
    TSOA generated routes for the REST API based on information
    provided in the controller files.
\end{verbatim}
\subsection{Root Files}
Some files relating package and actual server configuration do not really belong in any of the layers and so are stored at the root level.
\subsubsection{App.ts}
\begin{verbatim}
    The App.ts file contains all the logic for injecting
    all of the middleware into the application such as the custom
    error handlers, the rate limiting functionality from 
    RateLimiter.ts as well as the mongoose database connection 
    configuration.
    
    The file also defines a static route "/REST/1.0/documention"
    that serves the SwaggerUI HTML page from the swagger-ui-express
    package. The generateHTML() method is called on the TSOA
    generated OpenAPI Specification "swagger.json" and is
    returned as the routes response.
\end{verbatim}
\subsubsection{Server.ts}
\begin{verbatim}
    Simple configuration file for starting up the Node.js server.
\end{verbatim}
\subsubsection{tsoa.json}
\begin{verbatim}
    Configuration files for TSOA specifying the framework 
    that the routes should be generated for as well as the 
    directories for the different files to be pulled from and 
    where others will be generated.
\end{verbatim}
\subsection{Commands Used}
\subsubsection{Generating routes through TSOA}
\begin{verbatim}
    tsoa routes
\end{verbatim}
\subsubsection{Generating an OpenAPI Specification from the Controllers}
\begin{verbatim}
    tsoa spec
\end{verbatim}
\subsubsection{Compiling \& building the Service}
\begin{verbatim}
    tsc --outDir dist --experimentalDecorators
\end{verbatim}
\subsubsection{Starting the Service}
\begin{verbatim}
    node dist/Server.js
\end{verbatim}

\subsection{Overall Service Diagram}
INSERT DIAGRAM SHOWING HOW ALL THE FILES ETC COMMUNICATE I.E. CONTROLLER --> AGENT ETC, FLOW CHART TOO MAYBE? ERROR/SUCCESS FLOW..

\section{API Client}
The next part of the project will be determining the functionality that a generic API Client should have. This will allow me to work out what feature sets need to be added to the generated client templates later on. 

In order to do this I will create a custom handcrafted API client for my micro-service. The API Client will be built as an NPM Package essentially acting as a wrapper for other imported libraries. The architecture will be simple, with the package essentially broken down into two directories, \emph{utils} and \emph{microservice-client}.
\subsection{utils}
The \emph{utils} directory will store the more abstract functionality, the methods for generically making HTTP requests and handling errors without the context for the specific micro-service API.
\subsubsection{Http.ts}
\begin{verbatim}
    The Http file contains the Http class, built on top of the Axios library. 
    
    constructor()
        The constructor generates an AxiosInstance using the baseUrl and 
        optional customHeaders parameters that will be used for making the 
        HTTP requests. Upon creation the constructor will also inject the 
        interceptor for handling automatic retries of certain requests 
        into the AxiosInstance using the axios-retry library.
        
    request()
        Generic wrapper for the AxiosInstance.request() method. Injects a 
        custom error handler into the the response for the request() method 
        to insure all of the relevant error information from the API is 
        pulled out before being parsed as an ErrorWrapper object.
        
        The method signature allows inputting of the HTTP verb to be
        used, the URL endpoint to be requested as well as optional 
        fields for request body and query parameters.
        
        A switch statement is used based on the HTTP verb to determine
        how the request is going to be sent, and what parts of the request
        will be provided.
        
        Subsequent wrappers will be provided for this generic function
        each providing specific HTTP verb support.
        
    get()
        Wrapper for the request() method which injects the HTTP verb GET 
        into the method. Method signature provides a required parameter
        URL which will also be passed into the request() method when called.
        Optional parameters for query parameters also provided.
    
    post()
        This wrapper injects in the HTTP verb POST and contains required
        parameters for both URL and the request body, both of which are
        passed in the request() method.
        Optional parameters for query parameters also provided.
    
    put()
        This wrapper injects in the HTTP verb PUT and contains required
        parameters for both URL and the request body, both of which are
        passed in the request() method.
        Optional parameters for query parameters also provided.
    
    delete()
        Wrapper which injects the HTTP verb delete into the request()
        method alongside a URL, request body and optional query parameters.
        
\end{verbatim}
\subsubsection{HttpVerbs.ts}
\begin{verbatim}
    Simple enumeration type for defining the HTTP Verbs used in the library.
\end{verbatim}
\subsubsection{ErrorWrapper.ts}
\begin{verbatim}
    Custom Error format shared with the same file in the micro-service. Used to
    ensure that no important information or context is lost when the errors are
    handled and passed through the library.
\end{verbatim}
\subsection{microservice-client}
This directory will be where the actual export functionality of the library will be located. It will contain a single file, handling the logic for directing the HTTP requests using the utility functions from the files in the \emph{utils} directory.
\subsubsection{MicroserviceClient.ts}
\begin{verbatim}
    The file defines the MicroserviceClient class. The class contains a member
    variable importing the Http class and wraps its methods with contextual
    information about the API endpoints and responses. 
    
    constructor()
        Simple constructor that creates a new Http instance using the 
        microservices base URL.
    
    createShoppingItem()
        Calls the Http.post() method passing in the a body passed
        from the method parameters and URL for the associated endpoint
        
    getShoppingItems()
        Calls the Http.get() method with the URL for the API endpoint and
        and passes in optional query parameter object from the optional
        method parameters
    
    getShoppingItem()
        Calls the Http.get() method with a custom URL with path parameters
        from the method parameters
    
    increaseShoppingItemStock()
        Calls the Http.put() method with the endpoint URL and a body
        built from the method parameters
    
    decreaseShoppingItemStock()
        Calls the Http.put() method with the endpoint URL and a body
        built from the method parameters
    
    updateShoppingItemCategory()
        Calls the Http.put() method with the endpoint URL and a body
        built from the method parameters
        
    deleteShoppingItem()
        Calls the Http.delete() method with the endpoint URL and a body
        built from the method parameters
        
\end{verbatim}
\subsection{Root Files}
\subsubsection{Index.ts}
\begin{verbatim}
    Basic file defining the functions that the library will expose as exports.
\end{verbatim}
\subsection{Building and Publishing the Library}
    Physically publishing the package is out of scope of the project, but I will explain how it would be done.

    Creating and publishing NPM modules is simple. The package.json files specifies a number of fields including name of the package, current version of the module as well as information about its git repository. Once the index file has been defined and the export members specified, the module can be published using the NPM or Yarn package managers.
    
    The module will then be stored on the module registry and can then be imported using a package manager. 
    
\section{Modifying the OpenAPI Code Generator}
\subsection{Generating the Client using the Base Templates}
In order to generate the Client I will use the openapi-generator-cli NPM package. This means that I do not have to fork and run the whole software stack locally until I have to.

Once the OpenAPI Specification has been created, the Client can be generated through simply running the command:
\begin{verbatim}
    openapi-generator-cli generate 
    -g typescript-axios 
    -i PATH_TO_SPECIFICATION
    -o OUTPUT_DIR
    --additional-properties=npmName=CLIENTNAME,
\end{verbatim}
The command will generate a new API client based on the base typescript-axios templates. By passing in the npmName field in as an additional property will cause the package.json files and other related NPM files to be automatically generated. This is necessary for both publication and for installing the libraries dependencies.
\subsection{Determining the differences between the generated client and my client}
The API clients generated contain a lot of overlapping features with my home-brewed client, as well as some functionality I omitted from it. Support for query parameters is provided and types are generated from the response and request body definitions allowing full type support for the method signatures generated. It also supports a number of different authentication and authorisation mechanisms including OAuth and use of JWT tokens, although my API does not utilise any of these technologies. All of the functionality is implemented using the same AxiosInstance integration within my implementation of the client allowing a lot of the feature sets of each to be readily injected into the other. 

The key pieces of missing functionality are the custom error handling for the failed API requests, with the bloat-heavy Axios errors being thrown by default, and no support provided for the automatic retries on failed requests.

TODO: insert venn diagram

\subsection{Modifying the generated client}
Due to the use of the same Axios library, and its AxiosInstance methods, most of the code from my custom client, and the clients generated by the OpenAPI Generator, is generally interchangeable.

Rather than jumping straight into modifying the Mustache template files, I can instead modify the raw TypeScript files that is output by the generator to test the interactions between the new code and the existing. This will make debugging any issues clearer than trying to get the generation to work on top of the actual code that is produced.

Adding support for the automatic retries on failed requests will be relatively simple, all I need to is add the axios-retry as a dependency and inject the same code I use within my code, into the AxiosInstance that the generated API used.

Parsing the errors thrown by the client will be handled in a similiar way. The file defining the custom ErrorWrapper class can simply be cut out of my code and pasted within the generated library, and the code for handling the error thrown can be cut out of my AxiosInstance definitions and used to catch the errors thrown by the new API client.

I will then test that the behaviour of the client is as expected by creating a test script that calls each of the API endpoints. The inputs will be a mixture of valid and invalid parameters to check to see that successful requests are still handled correctly, and that any errors thrown are sent in format that is expected. If all of the changes work as expected, I can move onto abstracting all of these changes into the template files.
\subsection{Modifying the template files}
The modifications that need to be made to the template files used in the generator will be relatively simple. All of the functionality related to actually populating fields with values from the specification is already in the generated client, and so all of the additions made will all be static blocks of code.

The custom ErrorWrapper class file can simply be cut and pasted within the template file directory, and the code defining up the error handler can be pulled from my API and copied into the templates. This will all be appended onto the template code relating to setting up the AxiosInstance that forms the basic of the API requests.

In the same vein getting the automatic retries working simply involves adding the axios-retry library into the template NPM package.json file  before cut-pasting the module setup into the AxiosInstance definitions.

Once the templates have been modified I can generate a new client using them. From that point I can use the same test script I used in the modifications to the vanilla client in order to check the functionality is still working.
\subsection{Conclusion}
In this chapter I have looked at the libraries I will be using in development of the software as well as API design and software architecture of the solutions. I have also described and made justifications all of the design decisions made, specifically around the interactions between the different layers of the micro-service and the file breakdown of my custom API client. A breakdown and explanation of how I plan on adding functionality into the OpenAPI Generator has also been described.