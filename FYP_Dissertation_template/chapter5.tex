\chapter{System Design}
\section{Introduction}
In this section of the report I will explain and justify the design decisions I have made relating to both the architecture of my systems, and the libraries they employ.

The project is going to consist of three differing systems. The first will be a Node.js TypeScript RESTful micro-service. It will be a pretty basic service, fulfilling the basic functionality expected of a modern micro-service. The second will be a TypeScript NPM module, acting as a client library that consumes the API of the micro-service and allows the Node.js service that imports the module to access the API. The final part of the project is a number of modifications made to the OpenAPI Generator typescript-axios templates. These changes will add any missing functionality to the generated client, using my NPM module as a baseline.

\subsection{Client-Server API Interactions}

The foundation of the project is in the interactions between micro-services. Each individual micro-service will utilise a RESTful API to expose its functionality to other services within the application through the use of HTTP requests. This follows the typical Client-Server model, where the service making the request acts as the client, and the owner of the API being requested acts as the server. Any number of micro-services can make requests to any of the APIs within the overarching application and so the system design needs to facilitate this in a scalable way.

INSERT API - API CLIENT DIAGRAM HERE

The end goal of the project is to provide the ability for all micro-services in a distributed application to produce an API client for their APIs that the other services can use without any client related code needing to be written. This will allow more development time to be put into the actual application logic of the system, reduce duplicated code across multiple services and provide a communication platform that is robust and reliable. 

\section{Premise of the micro-service}
The micro-service will be a fairly basic piece of software, aiming simply to provide the basic functionality required. As such the service will simulate a simple Stock Control component that could be used by a supermarket. It will be connected to a simple back-end database, and allow different products to be added, updated and deleted from the system. 

\section{RESTful API Design}
The first part of the system to be designed is the REST API for the exemplar micro-service. One of the key features of a micro-service architecture is that it allows the different services to be written in different frameworks and languages, and so the API must be language-agnostic. As such all request and response bodies will use JSON. This means that although the micro-service, based on the technology stack at Hindsight, will be a Node.js service written in TypeScript, theoretically any programming language that can handle JSON payloads will be supported.

In line with REST API best practises, all endpoint resources will be named with nouns, and the plural form will be used. The noun used for the base API will be shoppingItems. A shoppingItem representing one item within the API and shoppingItems representing the collection as a whole. 
As such, the base endpoint will be:
\begin{verbatim}
    /REST/1.0/shoppingItems
\end{verbatim}

Support will need to be provided for all CRUD operations for an API, supporting the HTTP verbs GET, POST, PUT and DELETE. Both a singular shoppingItem and the contents of the collection need to be fetched, and a subset of the properties of individual shoppingItems will need to be updated. New shoppingItems will need support for creation, and existing shoppingItems need to be able to be deleted.

\emph{Individual shoppingItems will have the following properties:}
\begin{verbatim}
    name: A string representing the unique name of the shoppingItem.
    category: An enumerated type representing the type of shoppingItem.
    numberOfStock: A representation of the number of the shoppingItem in stock
    inStock: A boolean representing the state of numberOfStock > 0
\end{verbatim}

\subsection{API Endpoints}
Descriptions of the planned API endpoints can be found below: 

\emph{All request and response bodies will be formatted as JSON.}

\begin{verbatim}
    GET /REST/1.0/shoppingItems
    Description:
        Retrieve all shoppingItems
    Query Parameters:
        page: page number of results returned by the query
        pageSize: the number of results per page
        inStock: filter items matching the inStock state provided
        category: filter items matching the category provided
    Additional note:
        Endpoint will be paginated, pages accessed using the page query 
        parameter + the page and totalPages fields within the response body
    Success Status Code: 200
    Response: 
        {
            shoppingItems: Array of ShoppingItems. Number of items in the
            array is either the default value, or the query parameter
            pageSize.
            page: current page number
            totalPages: number of total pages
        }
\end{verbatim}\medskip

\begin{verbatim}
    POST /REST/1.0/shoppingItems
    Description:
        Create a new shoppingItem
    Request Body:
        {
            name: Name of the new shoppingItem,
            category: Category of the new shoppingItem,
            numberOfStock: Number of stock for the new shoppingItem,
        }
    Success Status Code: 201
    Response: No Response returned
\end{verbatim}\medskip

\begin{verbatim}
    GET /REST/1.0/shoppingItems/{name}
    Description:
        Get an individual shoppingItem by name
    Path parameters:
        name: The name of the item being queried
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip

\begin{verbatim}
    DELETE /REST/1.0/shoppingItems/{name}
    Description:
        Delete an individual shoppingItem by name
    Path parameters:
        name: The name of the item being queried
    Success Status Code: 204
    Response: No Response returned
\end{verbatim}\medskip

\begin{verbatim}
    PUT /REST/1.0/shoppingItems/{name}/increaseStock
    Description:
        Increase the named shoppingItem stock by value provided in body
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            value: number to increment by
        }
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip

\begin{verbatim}
    PUT /REST/1.0/shoppingItems/{name}/decreaseStock
    Description:
        Decrease the named shoppingItem stock by value provided in body
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            value: number to decrement by
        }
    Success Status Code: 200
    Response:
        shoppingItem
\end{verbatim}\medskip


\begin{verbatim}
    PUT /REST/1.0/shoppingItems/{name}/category
    Description:
        Update the named shoppingItem category
    Path parameters:
        name: The name of the item being queried
    Request Body:
        {
            category: new category value
        }
    Success Status Code: 200
    Response:
        shoppingItem
        
\end{verbatim}\medskip

\section{Technologies and Libraries}

The next stage of the design process is going to be determining any libraries and frameworks that I am going to use in the software. There is no point in redesigning the wheel, and well established libraries provide robust and well-tested solutions to common problems.

\subsection{Node.js}
The micro-service will be implemented using the Node.js run-time environment. This allows me to model the micro-service after the micro-services used at Hindsight and has the added benefit of providing me with familiarity, meaning I don't have to learn anything new. Node.js is used industry wide for back-end APIs due to its asynchronous and non-blocking event handling and is also relatively lightweight whilst maintaining good performance. Through the use of NPM, a package manager for Node.js, hundred of thousands of public libraries and modules can be imported and utilised, providing access to well-tested and reliable code. This allows Node.js developers to avoid writing common code, as well as providing them to modularise their code into both public and private packages that can be shared across code bases. During the development of both the micro-service and the client I will be importing a number of public NPM packages into my code.

\subsection{TypeScript}
Node.js services are traditionally written in vanilla JavaScript, but through the use of NPM support can also be added for TypeScript.

TypeScript at its core is just a superset of JavaScript, aiming to alleviate some of the foundational issues with language by adding features such strong type and generics support to JavaScript. Upon compilation, TypeScript is compiled back into vanilla JavaScript and so can typically be used anywhere JavaScript is used.

Having used both JavaScript and TypeScript during development of micro-services, I could never go back to JavaScript. Personally I find the support added by TypeScript allows me to develop software far, far faster. The addition of types allows methods to define exactly what they return, and when tied in with a good IDE, the code prediction facilities provided by TypeScript allow a far more agile way of working. TypeScript code is also naturally documented by its types, parameters types are explicitly specified allowing some issues to show up as errors in the IDE before any code is even run through type checking.

Because TypeScript is a superset of JavaScript, if for some reason some component does need to be written in raw JavaScript, that is also accepted by the compiler.
\subsection{OpenAPI Specification}
The OpenAPI specification is a language-agnostic RESTful API specification that is widely used across the industry. In my opinion it is the most user-friendly specification out there and provides a huge ecosystem of different tools and integrations. It will be the API specification I will be using for this project. 

The specification document can be written in JSON or YAML, and provides details about all aspects of the REST API. When tied into language-specific tools the API specification can be used to generate both API clients and servers.
\subsection{Micro-service specific libraries}

In this section I will describe and justify the libraries and frameworks I have decided to use in development of the exemplar micro-service.

\subsubsection{Express.js}
Express.js is a framework I will be using as the base of my micro-service. The Node.js ecosystem contains a number of widely used frameworks, but Express.js is arguably the most popular. It is lightweight and extensible, and handles a lot of the more tedious aspects of setting up a Node.js application. Express allows middleware to be easily plugged in, allowing a developer to easily import and use libraries for handling a huge volume of different use cases. Common middleware includes cookie and session support as well as things like custom error handling.

The Express framework is also the framework that most of the micro-services at Hindsight use, and so I am also very familiar with it.
\subsubsection{TSOA}
TSOA is an NPM library that that aims to treat the controller and data models of an application as the single source of an truth for the API. It defines routes for the endpoints and validates request payloads based on information provided the controllers and data models.The beauty of this approach is that as changes are made to either of these two parts of the system, the API is automatically updated to support the changes. TSOA allows tightly-woven typings across the application, all the way from the database layers up to the responses returned by the controllers.

The library uses a number of decorators in conjunction with TypeScript in order to define how the generated API will function. The developer decorates the methods in the controllers with information about the endpoint URL, HTTP verbs to support and default response code that the endpoint will return. Parameters within the controller methods are then decorated to define URL path parameters, query parameters as well as the request body payload. TSOA automatically picks up the response for the endpoint from the return type of the method. 

It generates routes for a number of different frameworks, including Express, and automatically validates incoming data against the API definitions. If the format of the data sent is not as expected, or the fields do not match, then it will reject the request and throw an error.

TSOA can also generate an OpenAPI Specification for the API.Through usage of the JSDoc markup language, tonnes of additional information can be added to allow the generated specification to act more like living documentation for the API. Example requests and responses payloads can be included, as well as endpoint and parameter descriptions.

The library does a lot of the heavy lifting for a micro-service, especially the tasks concerning routing and data validation, alongside handling the OpenAPI Specification requirement and so TSOA will be an integral part of the technology stack I use.
\subsubsection{Swagger-UI-Express}
Swaggger-UI-Express is another NPM package that generates Swagger-UI based API Documentation. It essentially takes an OpenAPI Specification in JSON format, and generate a HTML page representing the specification in an easily-readable format.

It also allows requests to be made to the API directly from the web page, allowing the API to be utilised without any client related code. This allows easy testing of the API during development without having to manually type out convoluted CURL commands in order to make requests.

When injected as middleware, the package can be used to create a documentation endpoint that automatically serves the Swagger-UI HTML page. By tying in both this package, and TSOAs specification generation, we can automatically publish API documentation. This means that as soon as code changes are published, a new API specification will be generated  and documentation for the modified API will follow instantly.
\subsubsection{Express-Rate-Limit}
This NPM package is a very simple rate limiting middleware. It is lightweight, but comes with the caveat that it recognises are requests as coming from  the same entity, and so all users will share the same rate limit timer. As this project is focussed on the interactions between an API client and server, this limitation is a non-issue, and this library provides the rate limiting proof of concept needed for the clients functionality to be testing against.
\subsubsection{Mongoose}
In order to properly support the CRUD requirements of the API, a simple and lightweight MongoDB database will be integrated into the micro-service.

Mongoose is an NPM module that handles the vast majority of the logic involved in creating and interacting with a MongoDB database, cutting down on a huge volume of otherwise boilerplate code. It is schema-based, and so can also validate requests made to and from the database. It also provides support for injecting TypeScript types into its model definitions, allowing strongly typed response definitions to be returned from database queries. This allows the same type definitions to be used across all layers of the micro-service, and when used with TSOA decorators can provide API definitions using these typings. This means if the underlying database format and specifications are changed, then the API definition itself will be changed too.
\subsubsection{Mongoose-Pagination-V2}
The Mongoose-Pagination-V2 NPM package is a library that provides access to a Mongoose plugin. The plugin facilitates the use of a wrapper method on database queries that splits up the result of the query into paginated chunks.

Pagination can be fairly easily obtained using vanilla Mongoose via the Skip and Limit operators. Skip simply tells the query to Skip x number of documents, whereas Limit gives an upper bound on the number of documents returned. Pagination can be simulated by setting the value of Skip to the Page Number of the request multiplied by the value of Limit. This will set the starting position of the query to the "Page Number" requested. However this approach does not easily expose the number of available pages to the consumer of the request and so makes iterating through the pagination less friendly. It is also not scalable for huge collections, and the use of Skip and Limit can become CPU and I/O bound for large sets of documents.

SEE NOTE:
FROM MONGOOSE DOCS 
The cursor.skip() method is often expensive because it requires the server to walk from the beginning of the collection or index to get the offset or skip position before beginning to return result. As offset (e.g. pageNumber above) increases, cursor.skip() will become slower and more CPU intensive. With larger collections, cursor.skip() may become IO bound.
REFERENCE THIS LATER

The Mongoose-Pagination-V2 library instead is cursor-based and so does not have the same scalability concerns. It also provides all of the extra meta-data related to pagination and makes exposing exactly what data is being displayed to the user painless.

\subsection{Client specific libraries}
In this section I will look at  the tools and libraries I will within the API Client, as well as how I plan on publishing the client as a module. 
\subsubsection{Creating the Client as an NPM Library}
Seeing as the project is based on Node.js micro-services, configuring the Client library as an NPM library makes the most sense. The Client can easily be packaged and published to the NPM registry, either publicly or privately, and the micro-services can then readily install and utilise it. This also allows me to import other NPM packages as dependencies for my client, saving on the amount of otherwise unnecessary home-brewed code. Physically publishing the package is out of scope of this project, but the fundamental setup for the process will be done.
\subsubsection{Axios}
The key functionality of an API client is making requests to an API, and so choosing the right library for making HTTP requests is key.

The library Request is a very popular and easy to use solution for making HTTP requests, and is what a lot of the Hindsight micro-services use to communicate between services. The library was however deprecated in early 2020, and so following developer best practises, an alternative should be used.

Axios is a widely used alternative to Request. It provides a lot of powerful functionality like the ability to cancel requests, and automatically parses JSON data and encodes URL parameters. Requests can be heavily configured, providing options for things like transformation of request data into different formats, serialisation of parameters and the use of proxy servers.

Axios is also promise based. Node.js is asynchronous, and promises are a mechanism for dealing with asynchronicity without having to resort to a large number of callbacks. This usage of promises allows Axios to provide the ability to intercept both requests and responses before they are passed back to the calling function. A key use case for this in my project will be facilitating automatic retries on certain failed requests. 
\subsubsection{Axios-Retry}
Axios-Retry is a simple NPM library that provides access to an Axios interceptor that allows failed requests to be caught and sent again. The interceptor can be configured to retry the request any amount of times, and can take in arguments for delays between retries as well as conditions for which status codes get retried. Although fundamentally a very small library, it saves me from writing code unnecessarily. 

\subsection{OpenAPI Code Generator}
The OpenAPI Generator provides a huge number of template configurations supporting different programming languages and frameworks. In this section I will explain why I chose the typescript-axios option.
\subsubsection{The typescript-axios templates}
The base of my handmade REST Client is the Axios HTTP library, and so utilising the typescript-axios configuration for the OpenAPI Generator should make pulling changes across the software fairly simple.

The generated client is also setup as an NPM package, and so fulfils my concerns around easily importing and using the client in Node.js services. As a baseline, the generated code only has TypeScript and Axios as dependencies and therefore has no deprecated libraries in use. This should make it a fairly stable option longterm as Axios and TypeScript are both likely to stick around. 
\section{Microservice}
The micro-service will be broken down into a three layer architecture: the data layer, middleware layer and service layer.
\subsection{data-layer}
This layer will handle all of the business logic of the service, namely interacting with the database in order to fetch the information sent and requested through the API.
\subsubsection{models/ShoppingItemModel.ts}
The models directory will be where the Mongoose models and schemas for the service are defined. The schemas define the fields required for the documents within a collection, allowing validation by Mongoose automatically when the create and update wrappers are called. The model acts as interface for interacting with the schema, wrapping the CRUD operations boilerplate and packaging it into a simple object.  
\begin{verbatim}
        This file will define the Mongoose schema for the ShoppingItem 
        collection. It will define the shape of the data, and create the
        actual collection in MongoDB. It will then create a Mongoose 
        model that exposes all of the CRUD operations related to the 
        collection. This will allow the data-agents to  interact with
        the database without writing unnecessary boilerplate code. The
        Mongoose-Paginate-V2 plugin will also be wired into the schema 
        providing isolated access to the paginate functionality within
        only this collection. If any further collections are to be added,
        the pagination function will not be needed as default and so the
        dependency is unnecessary.
\end{verbatim}
\subsubsection{data-agents/ShoppingItemAgent.ts}
The data-agents acts as a middleman between the controllers and the models. They take the data passed in from the controllers, do any processing or formatting required for the actual database queries. They then pass in the formatted data into the wrapper methods from the model with any configuration options relevant to the request. They then do any post-processing on the results that the controller might need before bubbling the result back up. The data-agents also handle and wrap any errors that might be thrown by the models and transform them into more helpful HTTP errors.
\begin{verbatim}
        The ShoppingItemAgent will be the data-agent responsible for 
        calling and handling the ShoppingItemModel. It will contain 
        a method related to each of the REST API endpoints, and 
        using the data passed into it from the ShoppingItemController
        will interact with the ShoppingItem collection. It will handle
        any logic involved in both the pre and post-processing of data
        and will map an errors thrown into one of the errors from the 
        ErrorLibrary.
        
        createShoppingItem()
            Method related to the creation of a ShoppingItem within the
            database. Will call the findOneAndUpdate() model method. The use
            of the ShoppingItem name as the unique identifier for the
            collection means that namespace collisions need to be avoided
            and so using the findOneAndUpdate function with the upsert flag
            set will overwrite the previous document with the name if the same
            name is used again.
        
        getShoppingItem()
            Fetch an individual ShoppingItem from the collection based on a
            name field passed in. Simple usage of the findOne() model method
            using a query built around the name field. If no results are 
            returned then a custom ShoppingItemNotFoundError is thrown with 
            an assigned HTTP status code of 404.
        
        getShoppingItems()
            Method for requesting multiple ShoppingItems, either the entire
            collection, or a subset based on parameters for ShoppingItemCategory
            or the inStock boolean.
            Results will be paginated, and information related to current page
            and total number of pages will be returned in the response.
            Different pages can be accessed through usage of the Page parameter 
            and the number of results per page can be changed through the 
            PageSize parameter. If no results are found an empty array will be
            returned. 
        
        updateShoppingItemCategory()
            Simply update the ShoppingItemCategory of the document with the
            queried name. Uses the findOneAndUpdate() model method and the
            new, updated version of the document will be returned. If no results 
            are  found for the name passed in then a custom 
            ShoppingItemNotFoundError is thrown with an assigned HTTP status 
            code of 404.
        
        
        increaseShoppingItemStock()
            Increment the NumberOfStock field of the document with the name
            passed in by the number in the value field. If the stock level is
            raised from 0 then the boolean InStock will be flipped. Again the
            method uses findOneAndUpdate() and returns the updated document.
            If no ShoppingItem is found  with the queried name then a custom  
            ShoppingItemNotFoundErroris thrown with an assigned HTTP status 
            code of 404.
            
        decreaseShoppingItemStock()
            Decrement the NumberOfStock of the targeted document. Validation
            catches negatives number and sets the NumberOfStock to 0 in these
            cases. Model method used is findOneAndUpdate() with the modified 
            form of the document being returned. If no ShoppingItem is found 
            with the queried name then a custom  ShoppingItemNotFoundError 
            is thrown with an assigned HTTP status code of 404.
        
        deleteShoppingItem()
            Delete the targeted ShoppingItem using the name field. Uses the
            model function findOneAndRemove() to handle the deletion. If no 
            ShoppingItem is found with the name passed in then a custom 
            ShoppingItemNotFoundError is thrown with an assigned HTTP 
            status code of 404.
        
\end{verbatim}
\subsection{middleware}
This will be where the logic used across the micro-service will be abstracted and stored, mainly TypeScript types and error definitions. This will also be where the literal middleware is configured such as the rate limiting configuration and error handler.
\subsubsection{enums/ShoppingItemCategories.ts}
Simple enumeration types library for the micro-service. Helpful for ensuring only certain field values can get through the TSOA validation and across the controllers and data-agents.
\begin{verbatim}
        A simple enumeration type detailing the valid ShoppingItem categories.
\end{verbatim}
\subsubsection{types/ErrorLibrary.ts}
\begin{verbatim}
        The ErrorLibrary takes the generic ErrorWrappers and contextualises them
        by assigning a value to the unique ErrorIdentifier field. 
        This allows the error to be easily identified at a glance. We can simply 
        look at where the specific error in the library is thrown and 
        investigate the cause from there. Not so important in this small 
        service, but in a  large distributed system, identifying the root cause
        of errors  is extremely important and so this added context is a 
        necessity as errors  will be potentially bubbling up across multiple 
        services.
\end{verbatim}
\subsubsection{ShoppingItem.ts}

\begin{verbatim}
        Simple TypeScript interface for defining the ShoppingItem type for
        use across the service. Additionally usage of JSDoc annotation around
        the fields allows TSOA to add descriptions of each property to the
        OpenAPI Specification on generation.
\end{verbatim}
\subsubsection{ErrorHandler.ts}
\begin{verbatim}
        Custom error handling middleware. Has explicit handling of the
        ErrorWrapper errors thrown by the data-agents as well as handling
        the validation thrown by TSOA. This ensures the additional meta
        properties of the error are returned to the user and that the 
        status codes are set as expected.If the error is neither of 
        these formats it gets piped onto a handler for generic errors
        which uses a default error message and status code if they are
        missing.
        All of the error bodies are returned as JSON to maintain the
        language-agnostic nature of the API.
\end{verbatim}
\subsubsection{ErrorWrapper.ts}
\begin{verbatim}
        Custom extensions of the default Node.js Error object. Adds
        custom fields for additional details, status code and a unique
        error identifier. This generic ErrorWrapper is further extended
        by implementations for each expected HTTP status code, where the
        extended class simply defines the status code for its parent
        ErrorWrapper object.
\end{verbatim}
\subsubsection{RateLimiter.ts}

\begin{verbatim}
        Super simple implementation of the Express-Rate-Limit package,
        essentially assigning configuration values.
\end{verbatim}
\subsection{service-layer}
The Service layer will handle all of the logic associated with serving and processing the HTTP requests. This will be where all the controllers are defined and where the TSOA generated route files are created.
\subsubsection{controllers/ShoppingItemController.ts}
\begin{verbatim}
        The ShoppingItemController is where all of the TSOA related
        definitions and decorating is configured.
        
        The base ShoppingItemController class is decorated using
        the Route() decorator. This defines the base URL that
        all of the method specific URLs will append. In this case
        it is set to "/REST/1.0/shoppingItems".
        
        JSDoc notation will be used across the controller class,
        primarily before method definitions to provide TSOA with
        information about method descriptions and examples for fields and
        parameters.
        Additional decorators are injected in to help document any
        expected errors that the API will throw. This is done through
        the use of the @Res decorator and will add the error information
        to the OpenAPI Specification.
        
        Additonal Decorators used
            @Get @Post @Put @Delete: Map URL and HTTP Verb to the
            function. Under the hood URL is set to {baseUrl}/{URL}
            e.g. Get(/{name}) -> GET /REST/1.0/shoppingItems/{name}
            @Path(): Define a path parameter, maps the field within the
            URL to a variable.
            @Query(): Define a query parameter,maps the field within the
            URL to a variable.
            @Body(): Define the request body, maps the request body to a 
            variable.
            @Response(): Define errors, subtly different from @Res
            and only works with more static errors like the TSOA
            ValidationError.
            @Example(): Define an example response for the generated
            OpenAPI Specification.
            
        
        See the API documentation for detailed information on the API.
        
        createShoppingItem()
            Mapped to:
                POST /REST/1.0/shoppingItems
            Passes in the request body information to the createShoppingItem()
            function in the ShoppingItemAgent and decorates the response
            status code as 201 to represent the resource successfully being
            created.
        
        getShoppingItems()
            Mapped to:
                GET /REST/1.0/shoppingItems
            Calls getShoppingItems() method from the agent and passes in the
            optional query parameters for filtering and pagination if they are
            present. Simply returns the response from the agent alongside a
            200 status code.
        
        getShoppingItem()
            Mapped to:
                GET /REST/1.0/shoppingItems/{name}
            Passes in the path parameter name to the getShoppingItem() agent
            method. Returns the response from the function with a HTTP status
            code 200.
        
        updateShoppingItemCategory()
            Mapped to:
                PUT /REST/1.0/shoppingItems/{name}/category
            Call the updateShoppingItemCategory() agent function with both
            the name path parameter and the request body fields. As we are
            returning the updated document set the status code to 200.
            
        increaseShoppingItemStock()
            Mapped to:
                PUT /REST/1.0/shoppingItems/{name}/increaseStock
            Call the increaseShoppingItemStock() agent function with both
            the name path parameter and the request body fields. As we are
            returning the updated document set the status code to 200.
            
        decreaseShoppingItemStock()
            Mapped to:
                PUT /REST/1.0/shoppingItems/{name}/decreaseStock
            Call the decreaseShoppingItemStock() agent function with both
            the name path parameter and the request body fields. As we are
            returning the updated document set the status code to 200.
            
        deleteShoppingItem()
            Mapped to:
                DELETE /REST/1.0/shoppingItems/{name}
            Pass in the name path parameter to the deleteShoppingItem()
            agent method. Decorate the response status code as a 204 to
            inform the API consumer the resource was deleted. 
\end{verbatim}
\subsubsection{routes/Routes.ts}
\begin{verbatim}
        TSOA generated routes for the REST API based on information
        provided in the controller files.
\end{verbatim}
\subsection{Root Files}
Some files relating package and actual server configuration do not really belong in any of the layers and so are stored at the root level.
\subsubsection{App.ts}
\begin{verbatim}
        The App.ts file contains all the logic for injecting
        all of the middleware into the application such as the custom
        error handlers, the rate limiting functionality from 
        RateLimiter.ts as well as the mongoose database connection 
        configuration.
        
        The file also defines a static route "/REST/1.0/documention"
        that serves the SwaggerUI HTML page from the swagger-ui-express
        package. The generateHTML() method is called on the TSOA
        generated OpenAPI Specification "swagger.json" and is
        returned as the routes response.
\end{verbatim}
\subsubsection{Server.ts}
\begin{verbatim}
        Simple configuration file for starting up the Node.js server.
\end{verbatim}
\subsubsection{tsoa.json}
\begin{verbatim}
        Configuration files for TSOA specifying the framework 
        that the routes should be generated for as well as the 
        directories for the different files to be pulled from and 
        where others will be generated.
\end{verbatim}
\subsection{Commands Used}
\subsubsection{Generating routes through TSOA}
\begin{verbatim}
    tsoa routes
\end{verbatim}
\subsubsection{Generating an OpenAPI Specification from the Controllers}
\begin{verbatim}
    tsoa spec
\end{verbatim}
\subsubsection{Compiling \& building the Service}
\begin{verbatim}
    tsc --outDir dist --experimentalDecorators
\end{verbatim}
\subsubsection{Starting the Service}
\begin{verbatim}
    node dist/Server.js
\end{verbatim}

\subsection{Overall Service Diagram}
INSERT DIAGRAM SHOWING HOW ALL THE FILES ETC COMMUNICATE I.E. CONTROLLER --> AGENT ETC, FLOW CHART TOO MAYBE? ERROR/SUCCESS FLOW..

\section{API Client}
Intro
\subsection{Publishing the library}
    Basic explanation of NPM - package written -> goes to registry -> NPM/YARN install
\subsection{microservice-client}
\subsubsection{MicroServiceClient.ts}
\begin{verbatim}
\end{verbatim}
\subsection{utils}
\subsubsection{Http.ts}
\begin{verbatim}
    Http.ts
\end{verbatim}
\subsubsection{HttpVerbs.ts}
\begin{verbatim}
    HttpVerbs.ts
\end{verbatim}
\subsubsection{ErrorWrapper.ts}
\begin{verbatim}
    ErrorWrapper.ts
\end{verbatim}
\subsection{Root Files}
\subsubsection{Index.ts}
\begin{verbatim}
    Index.ts
\end{verbatim}

\section{Modifying the OpenAPI Code Generator}
\subsection{Generating the base client}
Commands - output -> not much to say really
\subsection{Determining the differences between the generated client and my client}
What is there, overlap, missing etc. Talk about overlap of Axios etc, justifies the choice of the option.
Venn diagram
\subsection{Modifying the generated client}
Changing the generated code, so changing the output of the command, not the files for templating
If it works move on, otherwise what should do etc
\subsection{Modifying the template files}
Pulling the changes made to gen code, forking the generator repo and modifying the mustache template files